<html>
  <head>
    <meta charset="utf-8" />
  </head>
  <body>
    <pre>
# 6502 gems

There are some truly beautiful pieces of 6502 assembly out there. I'd thought I
would collect a few here.

There written for the BBC Basic assembler so they can be tested using
bbcmic.ro, but generally do not make use of anything BBC Micro specific (like
API calls).

## Square root of unsigned 16 bit number

There are several places on the internet where this routine is listed, but it
is a beaut. I won't go into the all the details of how to compute a square
root, but to core is comparing what remains of the input number with something
that evolves like so:

01000000 00000000
0x010000 00000000
00xx0100 00000000
000xxx01 00000000
0000xxxx 01000000
....


The xx represents the root found so far, the 1 represents the digits to test
for. Maintaining this number could be costly, inserting a new result bit on the
right of xx, while keeping the 1 in the right place. What the routine below
does is put the xx-1 break on the byte boundary:

00000000 01000000
0000000x 01000000
000000xx 01000000
...


In this representation, shifting in the result bit is trivial. It does mean the
remainer has to be shifted left two places to align. Here it is:

numl = &70 : numh = &71 : root = &72 : rem = &73
DIM code% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.sqrt          \ calculate square root of numh|numl
 LDA #0
 STA root      \ init root
 STA rem       \ init remainder
 LDX #8
.sqrt_loop
 SEC           \ rem|numh - root|&40
 LDA numh
 SBC #&40
 TAY
 LDA rem
 SBC root
 BCC sqrt_next \ do not update remainder
 STY numh      \ update remainder
 STA rem
.sqrt_next
 ROL root      \ shift in result bit

 ASL numl      \ shift remainder left two places
 ROL numh
 ROL rem
 ASL numl
 ROL numh
 ROL rem

 DEX
 BNE sqrt_loop
 RTS
]:NEXT
n = 26482
r = INT(SQR(n))
PRINT r n-r*r
?numl = n
?numh = n DIV &100
CALL sqrt
PRINT ?root ?rem
END

## Multiplication

This routine is listed in the excellent Acorn Electron User Guide (page 224).
The elegance, and at the same time slight asymmetry, is the shifting of a
result bit into the carry at the end of the loop (ROR a), which is then shifted
into the result low byte at the start of the loop (ROR b). Because of this a
fixup of b is needed at the very end:

a = &70 : b = &71 : r = &72
DIM code% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.mul
 LDA #0       \ init high byte result
 LDX #8
.mul_loop
 ROR b        \ shift next bit multiplier into carry and shift low byte result right
 BCC mul_next \ no addition
 CLC          \ add multiplicand
 ADC a
.mul_next
 ROR A        \ shift high byte right
 DEX
 BNE mul_loop
 ROR b        \ final shift right for low byte result
 STA r
 RTS
]:NEXT
?a = 67
?b = 104
PRINT ?a * ?b
CALL mul
PRINT ?b OR 256 * ?r
END

The routine above only handles unsigned numbers, but can easily be adapted to
allow for a signed multiplicand.

a = &70 : b = &71 : r = &72
DIM code% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.mul
 LDA #0       \ init high byte result
 LDX #8
.mul_loop
 ROR b        \ shift next bit multiplier into carry and shift low byte result right
 BCC mul_next \ no addition
 CLC          \ add multiplicand
 ADC a
.mul_next
 CMP #&80     \ sign extension
 ROR A        \ shift high byte right
 DEX
 BNE mul_loop
 ROR b        \ final shift right for low byte result
 STA r
 RTS
]:NEXT
n = -43
?a = n
?b = 104
PRINT n * ?b
CALL mul
res = ?b OR 256 * ?r
IF res AND &8000 THEN res = res OR &FFFF0000
PRINT res
END


## Bayer 4x4 matrix

For ordered dithering, a Bayer matrix is required. Now, the most efficient way
is definitely a lookup table but I was interested in the most elegant way to
compute the matrix. The Bayer matrix is recursive with the following
transformation at each level:

0 1  ->  0 2
2 3      3 1

Or, writting in binary:

00  01  ->  00  10
10  11      11  01


The most significant bit is the exclusive OR of the two bits (X and Y), the
least significant bit is merely Y. The following code compute two levels
(4x4 matrix) but is easily changed to handle any number of levels.

eor = &70 : y = &71
DIM code% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.bayer   \ return matrix element at position X, Y in A
 STX eor
 STY y
 TYA
 EOR eor \ X ^ Y
 STA eor
 LDA #0  \ A = 0

 LSR eor \ shift in first eor bit
 ROL A
 LSR y   \ shift in first Y bit
 ROL A

 LSR eor \ shift in second eor bit
 ROL A
 LSR y   \ shift in second Y bit
 ROL A

 RTS
]:NEXT
FOR Y% = 0 TO 3
FOR X% = 0 TO 3
PRINT USR(code%) AND &amp;FF;
NEXT
PRINT
NEXT
END
    </pre>
  </body>
</html>
