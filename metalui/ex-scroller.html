<html>

<head>
  <meta charset="utf-8" />
</head>

<body>
  <script>
    (() => { "use strict"; const t = t => new Promise(((e, o) => { setTimeout((() => { e(void 0) }), t) })); class e { constructor(t) { this.x = t } map(t) { return new e(this.x) } } const o = (t, o) => o((t => new e(t)))(t).x; class n { constructor(t) { this.value = t, this.ref = 1, this.watchers = [], this[Symbol.asyncIterator] = async function* () { let t = this.ref; for (yield this.value; ;)t !== this.ref ? (t = this.ref, yield this.value) : await new Promise((t => { this.watchers.push(t) })) } } async notify(t) { const e = "function" == typeof t ? t(this.value) : t; if (e !== this.value) { this.value = e, this.ref += 1; for (const t of this.watchers.splice(0, this.watchers.length)) t(void 0) } } focus(...t) { const e = this; let n = []; return { [Symbol.asyncIterator]: async function* () { for await (const r of e) { const e = t.map((t => o(r, t))); (e.length !== n.length || e.some(((t, e) => t !== n[e]))) && (n = e, yield r) } } } } } Symbol.asyncIterator, document.createElement("div"); const r = async (e, o = {}) => { if (!Array.isArray(e)) return null === e ? [] : [document.createTextNode(String(e))]; const [n, i, ...s] = e, a = Object.entries(i).reduce(((t, [e, o]) => ("$" === e[0] && (t[e] = o), t)), { ...o }); if ("string" == typeof n) { const t = []; try { for (const e of s) t.push(...await r(e, a)) } catch (t) { if (i.errorBoundary) return [document.createTextNode(String(i.errorBoundary))]; throw t } if ("Fragment" === n) return t; const e = document.createElement(n); for (const [t, o] of Object.entries(i)) t.startsWith("on") ? e.addEventListener(t.substr(2), o) : t.startsWith("$") || e.setAttribute(t, String(o)); for (const o of t) e.appendChild(o); return [e] } const c = n({ ...a, ...i, children: s }); if (null === c || "object" != typeof c || Array.isArray(c)) return await r(c, a); const l = async (e, o) => { do { await t(0) } while (o && !e.isConnected); if (!e.isConnected) return void await c.return(); const n = await c.next(e); if (n.done) return; const i = await r(n.value, a); if (1 !== i.length) throw new Error(`Expect component to return single element, not ${i.length} elements`); const s = i[0]; if (s.tagName !== e.tagName) throw new Error(`Expect component to rerender with tag ${e.tagName.toLowerCase()}, not tag ${s.tagName.toLocaleLowerCase()}`); for (const t of s.getAttributeNames()) { const o = s.getAttribute(t); null !== o && e.setAttribute(t, o) } e.replaceChildren(...s.childNodes), l(e, !1) }, h = await c.next(); if (h.done) return []; const d = await r(h.value, a); if (1 !== d.length) throw new Error(`Expect component to return single node, not ${d.length} nodes`); return l(d[0], !0), d }, i = async function* ({ Body: t, totalHeight: e }) { const o = new n(0), r = yield ["div", { style: "height: 100%; position: relative;" }]; yield ["div", { style: "height: 100%; position: relative;" }, ["div", { style: "height: 100%; overflow-y: auto; width: 100%", onscroll: t => { o.notify(t.target.scrollTop) } }, ["div", { style: `height: ${e}px;` }]], ["div", { style: "height: 100%; overflow-y: hidden; position: absolute; top: 0px; width: calc(100% - 18px);" }, [t, { height: r && r.offsetHeight || 100, scrollOb: o }]]] }; (async () => { document.body.replaceChildren(...await r([() => { const t = new Array(1e5).fill(0).map((() => Math.random().toString(36).substr(2))); return ["div", { style: "width: 200px; height: 400px;" }, [i, { totalHeight: 19 * t.length, Body: async function* ({ height: e, scrollOb: o }) { for await (const n of o) { const o = Math.round(n / 19), r = Math.ceil(e / 19); yield ["div", {}, ...t.slice(o, o + r).map(((t, e) => ["div", { style: "height: 19px;" }, `${1 + o + e}: ${t}`]))] } } }]] }, {}])) })() })();
  </script>
</body>

</html>