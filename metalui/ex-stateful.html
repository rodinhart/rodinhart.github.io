<html>

<head>
  <meta charset="utf-8" />
</head>

<body>
  <script>
    (() => { "use strict"; const t = t => new Promise(((e, n) => { setTimeout((() => { e(void 0) }), t) })); class e { constructor(t) { this.x = t } map(t) { return new e(this.x) } } const n = (t, n) => n((t => new e(t)))(t).x; class o { constructor(t) { this.value = t, this.ref = 1, this.watchers = [], this[Symbol.asyncIterator] = async function* () { let t = this.ref; for (yield this.value; ;)t !== this.ref ? (t = this.ref, yield this.value) : await new Promise((t => { this.watchers.push(t) })) } } async notify(t) { const e = "function" == typeof t ? t(this.value) : t; if (e !== this.value) { this.value = e, this.ref += 1; for (const t of this.watchers.splice(0, this.watchers.length)) t(void 0) } } focus(...t) { const e = this; let o = []; return { [Symbol.asyncIterator]: async function* () { for await (const r of e) { const e = t.map((t => n(r, t))); (e.length !== o.length || e.some(((t, e) => t !== o[e]))) && (o = e, yield r) } } } } } Symbol.asyncIterator, document.createElement("div"); const r = async (e, n = {}) => { if (!Array.isArray(e)) return null === e ? [] : [document.createTextNode(String(e))]; const [o, s, ...a] = e, i = Object.entries(s).reduce(((t, [e, n]) => ("$" === e[0] && (t[e] = n), t)), { ...n }); if ("string" == typeof o) { const t = []; try { for (const e of a) t.push(...await r(e, i)) } catch (t) { if (s.errorBoundary) return [document.createTextNode(String(s.errorBoundary))]; throw t } if ("Fragment" === o) return t; const e = document.createElement(o); for (const [t, n] of Object.entries(s)) t.startsWith("on") ? e.addEventListener(t.substr(2), n) : e.setAttribute(t, String(n)); for (const n of t) e.appendChild(n); return [e] } const c = o({ ...i, ...s, children: a }); if (null === c || "object" != typeof c || Array.isArray(c)) return await r(c, i); const l = async (e, n) => { do { await t(0) } while (n && !e.isConnected); if (!e.isConnected) return void await c.return(); const o = await c.next(e); if (o.done) return; const s = await r(o.value, i); if (1 !== s.length) throw new Error(`Expect component to return single element, not ${s.length} elements`); const a = s[0]; if (a.tagName !== e.tagName) throw new Error(`Expect component to rerender with tag ${e.tagName.toLowerCase()}, not tag ${a.tagName.toLocaleLowerCase()}`); for (const t of a.getAttributeNames()) { const n = a.getAttribute(t); null !== n && e.setAttribute(t, n) } e.replaceChildren(...a.childNodes), l(e, !1) }, u = await c.next(); if (u.done) return []; const h = await r(u.value, i); if (1 !== h.length) throw new Error(`Expect component to return single node, not ${h.length} nodes`); return l(h[0], !0), h }; (async () => { const e = (t, ...e) => { const n = new Set(t); for (const t of e) n.delete(t); return n }, n = async () => (await t(42), ["Apples", "Bananas", "Chocolate"]), s = new o({ selected: new Set(["Bananas"]) }); document.body.replaceChildren(...await r([async function* ({ stateOb: t }) { const o = n => t.notify((t => ({ ...t, selected: t.selected.has(n) ? e(t.selected, n) : new Set([...t.selected, n]) }))); for await (const { selected: e } of t) { if (!e) return; const t = await n(); yield ["div", {}, ["ul", {}, ...t.map((t => ["li", { style: e.has(t) ? "font-weight: bold;" : "", onclick: () => o(t) }, t]))]] } }, { stateOb: s }])) })() })();
  </script>
</body>

</html>