<html>

<head>
  <meta charset="utf-8" />
</head>

<body>
  <script>
    (() => { "use strict"; const t = t => new Promise(((e, n) => { setTimeout((() => { e(void 0) }), t) })); class e { constructor(t) { this.x = t } map(t) { return new e(this.x) } } const n = (t, n) => n((t => new e(t)))(t).x; class r { constructor(t) { this.value = t, this.ref = 1, this.watchers = [], this[Symbol.asyncIterator] = async function* () { let t = this.ref; for (yield this.value; ;)t !== this.ref ? (t = this.ref, yield this.value) : await new Promise((t => { this.watchers.push(t) })) } } async notify(t) { const e = "function" == typeof t ? t(this.value) : t; if (e !== this.value) { this.value = e, this.ref += 1; for (const t of this.watchers.splice(0, this.watchers.length)) t(void 0) } } focus(...t) { const e = this; let r = []; return { [Symbol.asyncIterator]: async function* () { for await (const o of e) { const e = t.map((t => n(o, t))); (e.length !== r.length || e.some(((t, e) => t !== r[e]))) && (r = e, yield o) } } } } } Symbol.asyncIterator, document.createElement("div"); const o = async (e, n = {}) => { if (!Array.isArray(e)) return null === e ? [] : [document.createTextNode(String(e))]; const [r, a, ...s] = e, i = Object.entries(a).reduce(((t, [e, n]) => ("$" === e[0] && (t[e] = n), t)), { ...n }); if ("string" == typeof r) { const t = []; try { for (const e of s) t.push(...await o(e, i)) } catch (t) { if (a.errorBoundary) return [document.createTextNode(String(a.errorBoundary))]; throw t } if ("Fragment" === r) return t; const e = document.createElement(r); for (const [t, n] of Object.entries(a)) t.startsWith("on") ? e.addEventListener(t.substr(2), n) : t.startsWith("$") || e.setAttribute(t, String(n)); for (const n of t) e.appendChild(n); return [e] } const c = r({ ...i, ...a, children: s }); if (null === c || "object" != typeof c || Array.isArray(c)) return await o(c, i); const l = async (e, n) => { do { await t(0) } while (n && !e.isConnected); if (!e.isConnected) return void await c.return(); const r = await c.next(e); if (r.done) return; const a = await o(r.value, i); if (1 !== a.length) throw new Error(`Expect component to return single element, not ${a.length} elements`); const s = a[0]; if (s.tagName !== e.tagName) throw new Error(`Expect component to rerender with tag ${e.tagName.toLowerCase()}, not tag ${s.tagName.toLocaleLowerCase()}`); for (const t of s.getAttributeNames()) { const n = s.getAttribute(t); null !== n && e.setAttribute(t, n) } e.replaceChildren(...s.childNodes), l(e, !1) }, u = await c.next(); if (u.done) return []; const h = await o(u.value, i); if (1 !== h.length) throw new Error(`Expect component to return single node, not ${h.length} nodes`); return l(h[0], !0), h }; (async () => { document.body.replaceChildren(...await o([async function* () { const t = new r(0), e = new r(0), n = setInterval((() => { Math.random() < .5 ? t.notify((t => t + 1)) : e.notify((t => t + 1)) }), 1e3); try { for await (const [n, r] of ((...t) => ({ [Symbol.asyncIterator]: async function* () { const e = t.map((t => t[Symbol.asyncIterator]())), n = await Promise.all(e.map((t => t.next().then((t => t.value))))); yield n; const r = e.map(((t, e) => t.next().then((t => [t.value, e])))); for (; ;) { const [t, o] = await Promise.race(r); n[o] = t, r[o] = e[o].next().then((t => [t.value, o])), yield n } } }))(t, e)) yield ["ul", {}, ["li", {}, `Heads: ${n}`], ["li", {}, `Tails: ${r}`]] } finally { clearInterval(n) } }, {}])) })() })();
  </script>
</body>

</html>